
/**
 * File generated by Jenny -- https://github.com/LanderlYoung/Jenny
 *
 * DO NOT EDIT THIS FILE.
 *
 * For bug report, please refer to github issue tracker https://github.com/LanderlYoung/Jenny/issues.
 */

#ifndef android_os_WakeLockProxy_H
#define android_os_WakeLockProxy_H

#include <QJniObject>
#include <cmath>

namespace android { namespace os {
class WakeLockProxy {
private:
    QJniObject m_jniObject;
    static constexpr double NaN = NAN;
public:
    static constexpr auto FULL_CLASS_NAME = "android/os/PowerManager$WakeLock";
    QJniObject getJniObject() const {return m_jniObject;}
    const QJniObject* operator->() const {return &m_jniObject;}
    template <class T> operator T() {return m_jniObject.object<T>();}
    WakeLockProxy() {}
    WakeLockProxy(const QJniObject& jniObject) {
        m_jniObject = jniObject;
    }
    WakeLockProxy(jobject globalRef) {
        m_jniObject = QJniObject(globalRef);
    }
    static WakeLockProxy fromLocalRef(jobject localRef) {
        WakeLockProxy res;
    res.m_jniObject = QJniObject::fromLocalRef(localRef);
    return res;
    }



    // method: public void setReferenceCounted(boolean value)
    auto setReferenceCounted(jobject enclosingClass, jboolean value) const {
        m_jniObject.callMethod<void>(
                        "setReferenceCounted",
                        "(Z)V", enclosingClass, value);
    }


    // method: public void acquire()
    auto acquire(jobject enclosingClass) const {
        m_jniObject.callMethod<void>(
                        "acquire",
                        "()V", enclosingClass);
    }


    // method: public void acquire(long timeout)
    auto acquire(jobject enclosingClass, jlong timeout) const {
        m_jniObject.callMethod<void>(
                        "acquire",
                        "(J)V", enclosingClass, timeout);
    }


    // method: public void release()
    auto release(jobject enclosingClass) const {
        m_jniObject.callMethod<void>(
                        "release",
                        "()V", enclosingClass);
    }


    // method: public void release(int flags)
    auto release(jobject enclosingClass, jint flags) const {
        m_jniObject.callMethod<void>(
                        "release",
                        "(I)V", enclosingClass, flags);
    }


    // method: public boolean isHeld()
    auto isHeld(jobject enclosingClass) const {
        return m_jniObject.callMethod<jboolean>(
                        "isHeld",
                        "()Z", enclosingClass);
    }


    // method: public void setWorkSource(android.os.WorkSource ws)
    auto setWorkSource(jobject enclosingClass, jobject ws) const {
        m_jniObject.callMethod<void>(
                        "setWorkSource",
                        "(Landroid/os/WorkSource;)V", enclosingClass, ws);
    }


    // method: public java.lang.String toString()
    auto toString(jobject enclosingClass) const {
        return m_jniObject.callMethod<jstring>(
                        "toString",
                        "()Ljava/lang/String;", enclosingClass);
    }


    // method: public void setStateListener(java.util.concurrent.Executor executor, android.os.PowerManager.WakeLockStateListener listener)
    auto setStateListener(jobject enclosingClass, jobject executor, jobject listener) const {
        m_jniObject.callMethod<void>(
                        "setStateListener",
                        "(Ljava/util/concurrent/Executor;Landroid/os/PowerManager$WakeLockStateListener;)V", enclosingClass, executor, listener);
    }


};
} } // endof namespace android::os


namespace android { namespace os {


} } // endof namespace android::os

#endif // android_os_WakeLockProxy_H


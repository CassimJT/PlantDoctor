
/**
 * File generated by Jenny -- https://github.com/LanderlYoung/Jenny
 *
 * DO NOT EDIT THIS FILE.
 *
 * For bug report, please refer to github issue tracker https://github.com/LanderlYoung/Jenny/issues.
 */

#ifndef android_os_PowerManagerProxy_H
#define android_os_PowerManagerProxy_H

#include <QJniObject>
#include <cmath>

namespace android { namespace os {
class PowerManagerProxy {
private:
    QJniObject m_jniObject;
    static constexpr double NaN = NAN;
public:
    static constexpr auto FULL_CLASS_NAME = "android/os/PowerManager";
    QJniObject getJniObject() const {return m_jniObject;}
    const QJniObject* operator->() const {return &m_jniObject;}
    template <class T> operator T() {return m_jniObject.object<T>();}
    PowerManagerProxy() {}
    PowerManagerProxy(const QJniObject& jniObject) {
        m_jniObject = jniObject;
    }
    PowerManagerProxy(jobject globalRef) {
        m_jniObject = QJniObject(globalRef);
    }
    static PowerManagerProxy fromLocalRef(jobject localRef) {
        PowerManagerProxy res;
    res.m_jniObject = QJniObject::fromLocalRef(localRef);
    return res;
    }

    static constexpr jint ACQUIRE_CAUSES_WAKEUP = 268435456;
    static constexpr auto ACTION_DEVICE_IDLE_MODE_CHANGED = u8"android.os.action.DEVICE_IDLE_MODE_CHANGED";
    static constexpr auto ACTION_DEVICE_LIGHT_IDLE_MODE_CHANGED = u8"android.os.action.LIGHT_DEVICE_IDLE_MODE_CHANGED";
    static constexpr auto ACTION_LOW_POWER_STANDBY_ENABLED_CHANGED = u8"android.os.action.LOW_POWER_STANDBY_ENABLED_CHANGED";
    static constexpr auto ACTION_LOW_POWER_STANDBY_POLICY_CHANGED = u8"android.os.action.LOW_POWER_STANDBY_POLICY_CHANGED";
    static constexpr auto ACTION_POWER_SAVE_MODE_CHANGED = u8"android.os.action.POWER_SAVE_MODE_CHANGED";
    static constexpr auto FEATURE_WAKE_ON_LAN_IN_LOW_POWER_STANDBY = u8"com.android.lowpowerstandby.WAKE_ON_LAN";
    static constexpr jint FULL_WAKE_LOCK = 26;
    static constexpr jint LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF = 2;
    static constexpr jint LOCATION_MODE_FOREGROUND_ONLY = 3;
    static constexpr jint LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF = 1;
    static constexpr jint LOCATION_MODE_NO_CHANGE = 0;
    static constexpr jint LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF = 4;
    static constexpr jint LOW_POWER_STANDBY_ALLOWED_REASON_ONGOING_CALL = 4;
    static constexpr jint LOW_POWER_STANDBY_ALLOWED_REASON_TEMP_POWER_SAVE_ALLOWLIST = 2;
    static constexpr jint LOW_POWER_STANDBY_ALLOWED_REASON_VOICE_INTERACTION = 1;
    static constexpr jint ON_AFTER_RELEASE = 536870912;
    static constexpr jint PARTIAL_WAKE_LOCK = 1;
    static constexpr jint PROXIMITY_SCREEN_OFF_WAKE_LOCK = 32;
    static constexpr jint RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY = 1;
    static constexpr jint SCREEN_BRIGHT_WAKE_LOCK = 10;
    static constexpr jint SCREEN_DIM_WAKE_LOCK = 6;
    static constexpr jint THERMAL_STATUS_CRITICAL = 4;
    static constexpr jint THERMAL_STATUS_EMERGENCY = 5;
    static constexpr jint THERMAL_STATUS_LIGHT = 1;
    static constexpr jint THERMAL_STATUS_MODERATE = 2;
    static constexpr jint THERMAL_STATUS_NONE = 0;
    static constexpr jint THERMAL_STATUS_SEVERE = 3;
    static constexpr jint THERMAL_STATUS_SHUTDOWN = 6;


    // method: public android.os.PowerManager.WakeLock newWakeLock(int levelAndFlags, java.lang.String tag)
    auto newWakeLock(jint levelAndFlags, jstring tag) const {
        return m_jniObject.callMethod<jobject>(
                        "newWakeLock",
                        "(ILjava/lang/String;)Landroid/os/PowerManager$WakeLock;", levelAndFlags, tag);
    }


    // method: public boolean isWakeLockLevelSupported(int level)
    auto isWakeLockLevelSupported(jint level) const {
        return m_jniObject.callMethod<jboolean>(
                        "isWakeLockLevelSupported",
                        "(I)Z", level);
    }


    // method: public boolean isScreenOn()
    auto isScreenOn() const {
        return m_jniObject.callMethod<jboolean>(
                        "isScreenOn",
                        "()Z");
    }


    // method: public boolean isInteractive()
    auto isInteractive() const {
        return m_jniObject.callMethod<jboolean>(
                        "isInteractive",
                        "()Z");
    }


    // method: public boolean isRebootingUserspaceSupported()
    auto isRebootingUserspaceSupported() const {
        return m_jniObject.callMethod<jboolean>(
                        "isRebootingUserspaceSupported",
                        "()Z");
    }


    // method: public void reboot(java.lang.String reason)
    auto reboot(jstring reason) const {
        m_jniObject.callMethod<void>(
                        "reboot",
                        "(Ljava/lang/String;)V", reason);
    }


    // method: public boolean isPowerSaveMode()
    auto isPowerSaveMode() const {
        return m_jniObject.callMethod<jboolean>(
                        "isPowerSaveMode",
                        "()Z");
    }


    // method: public java.time.Duration getBatteryDischargePrediction()
    auto getBatteryDischargePrediction() const {
        return m_jniObject.callMethod<jobject>(
                        "getBatteryDischargePrediction",
                        "()Ljava/time/Duration;");
    }


    // method: public boolean isBatteryDischargePredictionPersonalized()
    auto isBatteryDischargePredictionPersonalized() const {
        return m_jniObject.callMethod<jboolean>(
                        "isBatteryDischargePredictionPersonalized",
                        "()Z");
    }


    // method: public int getLocationPowerSaveMode()
    auto getLocationPowerSaveMode() const {
        return m_jniObject.callMethod<jint>(
                        "getLocationPowerSaveMode",
                        "()I");
    }


    // method: public boolean isDeviceIdleMode()
    auto isDeviceIdleMode() const {
        return m_jniObject.callMethod<jboolean>(
                        "isDeviceIdleMode",
                        "()Z");
    }


    // method: public boolean isDeviceLightIdleMode()
    auto isDeviceLightIdleMode() const {
        return m_jniObject.callMethod<jboolean>(
                        "isDeviceLightIdleMode",
                        "()Z");
    }


    // method: public boolean isLowPowerStandbyEnabled()
    auto isLowPowerStandbyEnabled() const {
        return m_jniObject.callMethod<jboolean>(
                        "isLowPowerStandbyEnabled",
                        "()Z");
    }


    // method: public boolean isExemptFromLowPowerStandby()
    auto isExemptFromLowPowerStandby() const {
        return m_jniObject.callMethod<jboolean>(
                        "isExemptFromLowPowerStandby",
                        "()Z");
    }


    // method: public boolean isAllowedInLowPowerStandby(int reason)
    auto isAllowedInLowPowerStandby(jint reason) const {
        return m_jniObject.callMethod<jboolean>(
                        "isAllowedInLowPowerStandby",
                        "(I)Z", reason);
    }


    // method: public boolean isAllowedInLowPowerStandby(java.lang.String feature)
    auto isAllowedInLowPowerStandby(jstring feature) const {
        return m_jniObject.callMethod<jboolean>(
                        "isAllowedInLowPowerStandby",
                        "(Ljava/lang/String;)Z", feature);
    }


    // method: public boolean isIgnoringBatteryOptimizations(java.lang.String packageName)
    auto isIgnoringBatteryOptimizations(jstring packageName) const {
        return m_jniObject.callMethod<jboolean>(
                        "isIgnoringBatteryOptimizations",
                        "(Ljava/lang/String;)Z", packageName);
    }


    // method: public boolean isSustainedPerformanceModeSupported()
    auto isSustainedPerformanceModeSupported() const {
        return m_jniObject.callMethod<jboolean>(
                        "isSustainedPerformanceModeSupported",
                        "()Z");
    }


    // method: public int getCurrentThermalStatus()
    auto getCurrentThermalStatus() const {
        return m_jniObject.callMethod<jint>(
                        "getCurrentThermalStatus",
                        "()I");
    }


    // method: public void addThermalStatusListener(android.os.PowerManager.OnThermalStatusChangedListener listener)
    auto addThermalStatusListener(jobject listener) const {
        m_jniObject.callMethod<void>(
                        "addThermalStatusListener",
                        "(Landroid/os/PowerManager$OnThermalStatusChangedListener;)V", listener);
    }


    // method: public void addThermalStatusListener(java.util.concurrent.Executor executor, android.os.PowerManager.OnThermalStatusChangedListener listener)
    auto addThermalStatusListener(jobject executor, jobject listener) const {
        m_jniObject.callMethod<void>(
                        "addThermalStatusListener",
                        "(Ljava/util/concurrent/Executor;Landroid/os/PowerManager$OnThermalStatusChangedListener;)V", executor, listener);
    }


    // method: public void removeThermalStatusListener(android.os.PowerManager.OnThermalStatusChangedListener listener)
    auto removeThermalStatusListener(jobject listener) const {
        m_jniObject.callMethod<void>(
                        "removeThermalStatusListener",
                        "(Landroid/os/PowerManager$OnThermalStatusChangedListener;)V", listener);
    }


    // method: public float getThermalHeadroom(int forecastSeconds)
    auto getThermalHeadroom(jint forecastSeconds) const {
        return m_jniObject.callMethod<jfloat>(
                        "getThermalHeadroom",
                        "(I)F", forecastSeconds);
    }


    // method: public java.util.Map<java.lang.Integer,java.lang.Float> getThermalHeadroomThresholds()
    auto getThermalHeadroomThresholds() const {
        return m_jniObject.callMethod<jobject>(
                        "getThermalHeadroomThresholds",
                        "()Ljava/util/Map;");
    }


};
} } // endof namespace android::os


namespace android { namespace os {


} } // endof namespace android::os

#endif // android_os_PowerManagerProxy_H

